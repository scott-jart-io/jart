// BSD 3-Clause License
//
// Copyright (c) 2020, Scott Petersen
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// 1. Redistributions of source code must retain the above copyright notice, this
//    list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
//
// 3. Neither the name of the copyright holder nor the names of its
//    contributors may be used to endorse or promote products derived from
//    this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package io.jart.async;

import java.nio.ByteBuffer;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.function.BiPredicate;

import com.ea.async.Async;

import io.jart.util.PausableExecutor;

/**
 * AsyncByteBufferReader implementation where data is provided by ByteBuffers passed to write method.
 */
public class AsyncByteBufferPipe implements AsyncByteBufferReader {
	private static ByteBuffer emptyByteBuffer = ByteBuffer.allocate(0);
	
	/**
	 * Simple POJO to hold a ByteBuffer and whether we need to copy the ByteBuffer if not consumed synchronously.
	 */
	private static class ByteBufferRef {
		public boolean needsCopy;
		public ByteBuffer byteBuffer;
	}
	private final PausableExecutor exec;
	private final AsyncPipe<ByteBufferRef> pipe;
	private ByteBufferRef curRef;
	
	/**
	 * Instantiates a new async byte buffer pipe.
	 *
	 * @param exec the Executor to use for read/write
	 */
	public AsyncByteBufferPipe(Executor exec) {
		this.exec = new PausableExecutor(exec);
		pipe = new AsyncPipe<ByteBufferRef>();
	}
	
	/**
	 * PausableExecutor (wrapping the Executor passed at instantiation) used by read and write.
	 *
	 * @return the pausable executor
	 */
	public PausableExecutor executor() { return exec; }
	
	// write a buffer to the queue
	// buffer is synchronously consumed
	/**
	 * Write.
	 *
	 * @param src the src
	 */
	// write a null to signify eof
	public void write(ByteBuffer src) {
		// write buffer as-is
		ByteBufferRef ref = new ByteBufferRef();
		
		ref.needsCopy = true;
		ref.byteBuffer = src;
		// start queuing tasks to catch anything generated by the write
		exec.pause();
		pipe.write(ref);
		// run queued tasks synchronously -- ideally this consumes the whole buffer
		exec.resumeSync();

		if(src == null)
			return;

		// lock the reference to replace the underlying buffer w/ a copy before returning
		synchronized(ref) {
			int remaining = src.remaining();

			ref.needsCopy = false;
			if(remaining == 0)
				ref.byteBuffer = emptyByteBuffer;
			else {
				ref.byteBuffer = ByteBuffer.allocate(remaining);
				ref.byteBuffer.put(src).rewind();
			}
		}
	}

	/**
	 * Read.
	 *
	 * @param consumer the consumer
	 * @return the completable future
	 */
	@Override
	public CompletableFuture<Void> read(BiPredicate<ByteBuffer, Boolean> consumer) {
		// try to do it in a fixed few iterations without AsyncLoop overhead
		for(int i = 0; i < 3; i++) {
			if(curRef != null) {
				boolean cont;
	
				synchronized(curRef) { // lock the reference so it isn't replaced under us
					do cont = consumer.test(curRef.byteBuffer, curRef.needsCopy);
					while(cont && curRef.byteBuffer != null && curRef.byteBuffer.hasRemaining());
				}
				if(!cont || curRef.byteBuffer == null)
					return AsyncLoop.cfVoid;
			}
			curRef = Async.await(pipe.read(exec));
		}

		// unbounded loop
		return AsyncLoop.doWhile(()->{
			boolean cont;

			synchronized(curRef) { // lock the reference so it isn't replaced under us
				do cont = consumer.test(curRef.byteBuffer, curRef.needsCopy);
				while(cont && curRef.byteBuffer != null && curRef.byteBuffer.hasRemaining());
			}
			if(!cont || curRef.byteBuffer == null)
				return AsyncLoop.cfFalse;

			curRef = Async.await(pipe.read(exec));
			return AsyncLoop.cfTrue;
		}, exec).thenApply((Boolean)->(Void)null);
	}
}
